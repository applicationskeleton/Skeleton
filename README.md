<a href="http://dx.doi.org/10.5281/zenodo.13750"><img src="https://zenodo.org/badge/doi/10.5281/zenodo.13750.svg" alt="10.5281/zenodo.13750"></a>


Skeleton
========

Application Skeleton is a simple and powerful tool to generate skeleton science and engineering applications (for example, modeling and simulation, data analysis) --- easy-to-program, easy-to-run applications --- that closely mimic a real applications' parallel or distributed performance at a task (but not process) level.

It is intended for applied computer scientists who need to use science and engineering applications to verify the effectiveness of new systems designed to efficiently run such applications, so that they can bypass obstacles that they often encounter when accessing and building real science and engineering applications. Using the applications generated by Application Skeleton guarantees that the CS systems' effectiveness on synthetic applications will apply to the real applications.
 
Application classes that can be represented include: bag of tasks, map reduce, multi-stage workflow, and variations of these with a fixed number of iterations.  These applications can be generally considered many-task applications.

Applications are described as one or more stages.

Stages are described as one more more tasks.  Stages can also be iterative.

Tasks can be serial or parallel, and have compute and I/O (read and write) elements.

Once created, the applications can be run on single-core, single-node, multi-core, or multi-node (distributed or parallel) computers, depending on what workflow system is used to run them. The generated applications are compatible with workflow system such as Swift and Pegasus, as well as the ubiquitous UNIX shell. The application can also be created as a generic JSON object that can be used by other systems such as the AIMES middleware.

=======

Documentation about Skeletons can be found in the report directory

If you have questions, need support, want to report a bug, or want to request a feature, please do so by opening a new issue -- https://github.com/applicationskeleton/Skeleton/issues/new

=======

Contributors are welcome!

Ideally, these can be made via pull requests to the repository.

To receive email about commits to this repository, join the Google Groups "skeleton-commits" group,
http://groups.google.com/group/skeleton-commits/subscribe


=======

A paper about the first version of Application Skeletons is:
Z. Zhang and D. S. Katz, "Application Skeletons: Encapsulating MTC Application Task Computation and I/O," Proceedings of 6th Workshop on Many-Task Computing on Grids and Supercomputers (MTAGS), (in conjunction with SC13), 2013. https://doi.org/10.1145/2503210.2503222

A paper about the current version is:
Z. Zhang and D. S. Katz, "Using Application Skeletons to Improve eScience Infrastructure," Proceedings of 10th IEEE International Conference on eScience, 2014.
https://doi.org/10.1109/eScience.2014.9 (paper).
http://www.slideshare.net/danielskatz/using-application-skeletons-to-improve-escience-infrastructure (slides).

A longer paper about Application Skeletons and Synapse work is:
D. S. Katz, A. Merzky, Z. Zhang, S. Jha, "Application Skeletons: Construction and Use in eScience," Future Generation Computing Systems, v.59. pp 114-124, 2016.
https://doi.org/10.1016/j.future.2015.10.001

